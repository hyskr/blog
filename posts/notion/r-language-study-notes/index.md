---
title: R语言学习笔记
date: '2024-03-12 02:14:00.000'
tags: []
description: ''
from_notion: https://www.notion.so/R-ad9a6bacd918456f90c8da2944d150aa
author: heziah
last_edited_time: '2024-03-12 03:30:00.000'
---
## 基本使用

### **扩展包使用**


```r
library(readr)
d <- read_csv("class.csv")
```

or


```r
d <- readr::read_csv("class.csv")
```

### 目录


```r
getwd()
setwd('')
```

### 帮助


```r
?mean
example(mean)
```

<br/>

### 注释和源文件框架

R源文件中用井号（`#`）开头的行， 以及行内从井号开始的部分为注释。

对于较长的源文件， 应适当分节， 在RStudio软件中， 可以用特殊的注释进行分节， 并可点击源程序编辑窗格右上角的“Outline”快捷图标显示源程序分节结构。

这种特殊的注释格式如：


```r
# 1. 辅助函数 ####
## 1.1 函数A ####
## 1.2 函数B ####
### 1.2.1 说明 ####
# 2. 输入数据 ####
# 3. 建模 ####
```

特殊注释的末尾有4个以上的井号， 开头用1到多个井号表示框架分级， 开头井号越少， 级别越高。

目前这样的特殊注释对中文的识别能力不好， 所以需要用编号数字帮助正确识别结构层级

### rstudio使用

[https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/rstudio-ide.pdf](https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/rstudio-ide.pdf)

## 常用数学函数

常用的数学函数有：

- 舍入：`ceiling`, `floor`, `round`, `signif`, `trunc`, `zapsmall`

- 符号函数 `sign`

- 绝对值 `abs`

- 平方根 `sqrt`

- 对数与指数函数 `log`, `exp`, `log10`, `log2`

- 三角函数 `sin`, `cos`, `tan`

- 反三角函数 `asin`, `acos`, `atan`, `atan2`

- 双曲函数 `sinh`, `cosh`, `tanh`

- 反双曲函数 `asinh`, `acosh`, `atanh`

有一些不太常用的数学函数：

- 贝塔函数 `beta`, `lbeta`

- 伽玛函数 `gamma`, `lgamma`, `digamma`, `trigamma`, `tetragamma`, `pentagamma`

- 组合数 `choose`, `lchoose`

- 富利叶变换和卷积 `fft`, `mvfft`, `convolve`

- 正交多项式 `poly`

- 求根 `polyroot`, `uniroot`

- 最优化 `optimize`, `optim`

- Bessel函数 `besselI`, `besselK`, `besselJ`, `besselY`

- 样条插值 `spline`, `splinefun`

- 简单的微分 `deriv`

如果自己编写的函数没有考虑向量化问题， 可以用`Vectorize()`函数将其转换成向量化版本。


```r
log(x, base = exp(1))   # 计算 x 的自然对数，可指定底数（base 参数），默认为 e
logb(x, base = exp(1))  # 计算 x 的对数，可指定底数（base 参数），默认为 e
log10(x)    # 计算 x 的以 10 为底的对数
log2(x)     # 计算 x 的以 2 为底的对数
log1p(x)    # 计算 log(1 + x)，主要用于当 x 接近 0 时避免精度损失

exp(x)      # 计算 e 的 x 次方，其中 e 是自然对数的底

expm1(x)    # 计算 exp(x) - 1，当 x 接近 0 时避免精度损失
```


```r
ceiling(x)  # 返回大于或等于 x 的最小整数，即向上取整

floor(x)    # 返回小于或等于 x 的最大整数，即向下取整

trunc(x, ...)   # 返回 x 的截断值，即去除小数部分，保留整数部分

round(x, digits = 0)    # 对 x 进行四舍五入，可指定保留的小数位数（digits 参数）

signif(x, digits = 6)   # 返回 x 的有效数字，保留指定位数的有效数字（digits 参数）
```


```r
abs(x)
sqrt(x)
```


```r
LETTERS
letters
month.abb
month.name
pi
```


```r
cos(x)      # 计算 x 的余弦值
sin(x)      # 计算 x 的正弦值
tan(x)      # 计算 x 的正切值

acos(x)     # 计算 x 的反余弦值，返回值在 [0, π] 范围内
asin(x)     # 计算 x 的反正弦值，返回值在 [-π/2, π/2] 范围内
atan(x)     # 计算 x 的反正切值，返回值在 [-π/2, π/2] 范围内
atan2(y, x) # 返回给定 x 和 y 坐标的反正切值，以弧度表示，其值在 [-π, π] 范围内

cospi(x)    # 计算 x 的 π 倍的余弦值
sinpi(x)    # 计算 x 的 π 倍的正弦值
tanpi(x)    # 计算 x 的 π 倍的正切值
```

### **分布函数和分位数函数**

例:


```r
dnorm(1.98)
## [1] 0.05618314pnorm(1.98)
## [1] 0.9761482qnorm(0.975)
## [1] 1.959964
```

`dnorm(x)`表示标准正态分布密度 . `pnorm(x)`表示标准正态分布函数。 `qnorm(y)`表示标准正态分布分位数函数 。 还有其它许多分布的密度函数、分布函数和分位数函数。 例如，


```r
qt(1 - 0.05/2, 10)
## [1] 2.228139
```

求自由度为10的t检验的双侧临界值。 其中`qt(y,df)`表示自由度为`df`的t分布的分位数函数。

为了获得更详细的与分布有关的函数的帮助信息， 可以在命令行中用`?Distributions`命令打开相应的帮助。

## **函数调用和自定义函数**

### 符合函数调用


```r
log(exp(1.0))
```

### 管道运算符


```r
exp(1.0) |> log()
```

### 自定义函数


```r
frat <- function(x){
	(1 + x + 2*x^2)/(1 + 3*x + 2*x^2 + x^3)
}
```

## **输出**

### 简单输出

命令行的计算结果直接显示在命令的后面。 在用`source()`运行程序文件时， 需要用`print()`函数显示一个表达式的结果，如：


```r
print(sin(pi/2))
## [1] 1
```

用`cat()`函数显示多项内容， 包括数值和文本， 文本包在两个单撇号或两个双撇号中，如:


```r
cat("sin(pi/2)=", sin(pi/2), "\n")
## sin(pi/2)= 1
```

`cat()`函数最后一项一般是`"\n"`, 表示换行。 忽略此项将不换行。

再次提示：要避免打开中文输入法导致误使用中文标点。

### 用`sink()`函数作运行记录

R使用经常是在命令行逐行输入命令（程序）， 结果紧接着显示在命令后面。 如何保存这些命令和显示结果？ 在R命令行中运行过的命令会被保存在运行的工作文件夹中的一个名为.Rhistory的文件中。 用`sink()`函数打开一个文本文件开始记录文本型输出结果。 结束记录时用空的`sink()`即可关闭文件不再记录。 如


```r
sink("tmpres01.txt", split=TRUE)
print(sin(pi/6))
print(cos(pi/6))
cat("t(10)的双侧0.05分位数（临界值）=", qt(1 - 0.05/2, 10), "\n")
sink()
```

`sink()`用作输出记录主要是在测试运行中使用， 正常的输出应该使用`cat()`函数、`write.table()`、`write.csv()`等函数。

## 绘图

### 绘制函数图像

`**curve()**`函数用于绘制函数的图形，它可以绘制在指定的区间上，也可以绘制在整个画布上。使用`**curve()**`函数时，需要提供一个R表达式，表示要绘制的函数，以及绘制的区间。`**curve()**`函数也可以接受一系列的参数，用于调整绘图的外观和样式。


```r
# 绘制正弦函数图形
curve(sin, from = -pi, to = pi, col = "red", lwd = 2, main = "Sine Curve", xlab = "X", ylab = "sin(X)")
# Usage
curve(expr, from = NULL, to = NULL, n = 101, add = FALSE,
      type = "l", xname = "x", xlab = xname, ylab = NULL,
      log = NULL, xlim = NULL, ...)
```

### 绘制图形

`**plot()**`函数主要用于绘制散点图、折线图、箱线图等常见的统计图形。它通常用于展示数据的分布情况、趋势以及异常值等。`**plot()**`函数可以接受多种参数，包括数据向量、数据框、矩阵等，以及一系列可选的图形参数，用于控制绘图的外观和样式。

示例：


```r
# 创建数据
x <- c(1, 2, 3, 4, 5)
y <- c(2, 4, 6, 8, 10)

# 绘制散点图
plot(x, y, main = "Scatter Plot", xlab = "X", ylab = "Y", col = "blue", pch = 16)
```

`**lwd**` 是用于设置图形中线条的宽度（line width）的参数。

## **变量**

整型、单精度、双精度、逻辑型、复数。

复数常量写法如`2.2 + 3.5i`, `1i`。

用`<-`赋值的方法定义变量。`<-`也可以写成`=`，但是`<-`更直观。

## 数值型向量及其运算

**向量**是将若干个基础类型相同的值存储在一起， 各个元素可以按序号访问。 如果将若干个数值存储在一起可以用序号访问， 就叫做一个数值型向量。

用`c()`函数把多个元素或向量组合成一个向量。如


```r
marks <- c(10, 6, 4, 7, 8)
x <- c(1:3, 10:13)
x1 <- c(1, 2)
x2 <- c(3, 4)
x <- c(x1, x2)
```

## 常用函数

### 排序函数

`sort(x)`返回排序结果。 `rev(x)`返回把各元素排列次序反转后的结果。 `order(x)`返回排序用的下标。如


```r
x <- c(33, 55, 11)
sort(x)
## [1] 11 33 55rev(sort(x))
## [1] 55 33 11order(x)
## [1] 3 1 2x[order(x)]
## [1] 11 33 55
```

例子中， `order(x)`结果中3是x的最小元素11所在的位置下标， 1是x的第二小元素33所在的位置下标， 2是x的最大元素55所在的位置下标。

### 统计函数

`sum`(求和), `mean`(求平均值), `var`(求样本方差), `sd`(求样本标准差), `min`(求最小值), `max`(求最大值), `range`(求最小值和最大值)等函数称为统计函数， 把输入向量看作样本，计算样本统计量。 `prod`求所有元素的乘积。

cumsum和cumprod计算累加和累乘积。如


```r
cumsum(1:5)
## [1]  1  3  6 10 15cumprod(1:5)
## [1]   1   2   6  24 120
```

其它一些类似函数有`pmax`, `pmin`, `cummax`, `cummin`等。

### 生成规则序列的函数

seq函数是冒号运算符的推广。 

- `seq(5)`等同于`1:5`。 

- `seq(11, 15, by=2)`产生11,13,15。

- `seq(0, 2*pi, length.out=100)`产生从0到的等间隔序列， 序列长度指定为100。

`rep()`函数用来产生重复数值。 

- `rep(0, n)`产生一个初值为零的长度为n的向量。 

- `rep(c(1,3), 2)`把第一个自变量重复两次， 结果相当于`c(1,3,1,3)`。

- `rep(c(1,3), c(2,4))`则需要利用R的一般向量化规则， 把第一自变量的第一个元素1按照第二自变量中第一个元素2的次数重复， 把第一自变量中第二个元素3按照第二自变量中第二个元素4的次数重复， 结果相当于`c(1,1,3,3,3,3)`。

- `rep(c(1,3), each=2)`可以重复完一个元素后再重复另一元素，用`each=`选项， 结果相当于`c(1,1,3,3)`。

有一点技术性的小问题： `1:5`和`seq(5)`的结果是整型（integer）的， `c(1,3,5)`和`seq(1, 5, by=2)`的结果是浮点型（double）的。

